Parameters:
  InstanceType:
    Description: EC2 instance type for the Redis cluster.
    Type: String
    Default: t4g.nano
    AllowedValues:
      - t4g.nano
      - t4g.micro
      - t4g.small
      - t4g.medium
      - t4g.large
      - t4g.xlarge
      - t4g.2xlarge
  VPCId:
    Description: Select the VPC for your resources
    Type: AWS::EC2::VPC::Id
  SubnetIds:
    Description: Select the Subnet
    Type: List<AWS::EC2::Subnet::Id>
  LatestECSOptimizedAMI:
    Description: AMI ID
    Type: "AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>"
    Default: /aws/service/ecs/optimized-ami/amazon-linux-2023/arm64/recommended/image_id
  SSHKey:
    Description: Name of the key pair to ssh into the EC2 instance
    Type: AWS::EC2::KeyPair::KeyName
  EBSecurityGroup:
    Description: Select the Custom Security Group that wraps the Elastic Beanstalk EC2 instances
    Type: AWS::EC2::SecurityGroup::Id

Resources:
  # ECSInstanceProfileRole:
  #   Type: AWS::IAM::Role
  #   Properties:
  #     AssumeRolePolicyDocument:
  #       Version: 2012-10-17
  #       Statement:
  #         - Effect: Allow
  #           Principal:
  #             Service: ec2.amazonaws.com
  #           Action: sts:AssumeRole
  #     ManagedPolicyArns:
  #       - arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role

  # ECSInstanceProfile:
  #   Type: AWS::IAM::InstanceProfile
  #   Properties:
  #     Roles:
  #       - !Ref ECSInstanceProfileRole

  # ECSLaunchTemplate:
  #   Type: "AWS::EC2::LaunchTemplate"
  #   DependsOn: ECSCluster
  #   Properties:
  #     LaunchTemplateData:
  #       ImageId: !Ref LatestECSOptimizedAMI
  #       SecurityGroupIds:
  #         - !GetAtt ECSSecurityGroup.GroupId
  #       InstanceType: !Ref InstanceType
  #       KeyName: !Ref SSHKey
  #       IamInstanceProfile:
  #         Arn: !GetAtt ECSInstanceProfile.Arn
  #       UserData: !Base64
  #         "Fn::Sub":
  #           - |-
  #             #!/bin/bash
  #             echo ECS_CLUSTER=${ClusterName} >> /etc/ecs/ecs.config;
  #           - ClusterName: !Sub ${AWS::StackName}-ECSCluster

  # ECSAutoScalingGroup:
  #   Type: "AWS::AutoScaling::AutoScalingGroup"
  #   DependsOn:
  #     - ECSCluster
  #     # - GatewayToInternet
  #   Properties:
  #     MinSize: "1"
  #     MaxSize: "1"
  #     DesiredCapacity: "1"
  #     LaunchTemplate:
  #       LaunchTemplateId: !Ref ECSLaunchTemplate
  #       Version: !GetAtt ECSLaunchTemplate.LatestVersionNumber
  #     VPCZoneIdentifier: !Ref SubnetIds
  #     Tags:
  #       - Key: Name
  #         PropagateAtLaunch: true
  #         Value: !Join
  #           - " - "
  #           - - ECS Instance
  #             - !Sub ${AWS::StackName}-ECSCluster

  # ECSCluster:
  #   Type: "AWS::ECS::Cluster"
  #   Properties:
  #     ClusterName: !Sub ${AWS::StackName}-ECSCluster
  #     ClusterSettings:
  #       - Name: containerInsights
  #         Value: disabled
  #     Configuration:
  #       ExecuteCommandConfiguration:
  #         Logging: DEFAULT
  #     ServiceConnectDefaults:
  #       Namespace: !Sub ${AWS::StackName}-ECSCluster
  #     Tags: []

  # ECSCapacityProvider:
  #   Type: "AWS::ECS::CapacityProvider"
  #   Properties:
  #     AutoScalingGroupProvider:
  #       AutoScalingGroupArn: !Ref ECSAutoScalingGroup
  #       ManagedScaling:
  #         Status: ENABLED
  #         TargetCapacity: 100
  #       ManagedTerminationProtection: DISABLED

  # ECSClusterCPAssociation:
  #   Type: "AWS::ECS::ClusterCapacityProviderAssociations"
  #   DependsOn: ECSCluster
  #   Properties:
  #     Cluster: !Sub ${AWS::StackName}-ECSCluster
  #     CapacityProviders:
  #       - !Ref ECSCapacityProvider
  #     DefaultCapacityProviderStrategy:
  #       - Base: 0
  #         Weight: 1
  #         CapacityProvider: !Ref ECSCapacityProvider

  # ECSSecurityGroup:
  #   Type: "AWS::EC2::SecurityGroup"
  #   Properties:
  #     GroupDescription: SG for ECS cluster
  #     GroupName: !Sub ${AWS::StackName}-ECSSecurityGroup
  #     VpcId: !Ref VPCId
  #     SecurityGroupIngress:
  #       - FromPort: 22
  #         ToPort: 22
  #         IpProtocol: tcp
  #         CidrIp: 0.0.0.0/0
  #       - FromPort: 22
  #         ToPort: 22
  #         IpProtocol: tcp
  #         CidrIpv6: "::/0"
  #       - FromPort: 6379
  #         ToPort: 6379
  #         IpProtocol: tcp
  #         SourceSecurityGroupId: !Ref EBSecurityGroup
  #     Tags:
  #       - Key: Name
  #         Value: !Join [_, [!Ref "AWS::StackName"]]

  RedisPrivateHostedZone:
    Type: AWS::Route53::HostedZone
    Properties:
      Name: !Sub ${AWS::StackName}-redis-dns
      HostedZoneConfig:
        Comment: "Private hosted zone to route traffic to Redis cluster instance"
      VPCs:
        - VPCId: !Ref VPCId
          VPCRegion: !Ref AWS::Region

  RedisInstanceDnsRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref RedisPrivateHostedZone
      Name: !Sub "api.${AWS::StackName}-redis-dns"
      Type: A
      TTL: "20"
      ResourceRecords:
        - 172.31.255.0 # provide an IP that's part of the VPC but unused (not part of any subnets)

  DNSRecordLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaRoute53UpdatePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - route53:ChangeResourceRecordSets
                  - route53:GetHostedZone
                Resource: !Sub "arn:aws:route53:::hostedzone/${RedisPrivateHostedZone}"

  DNSRecordLambdaUpdate:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt DNSRecordLambdaExecutionRole.Arn
      Environment:
        Variables:
          HOSTED_ZONE_ID: !Ref RedisPrivateHostedZone
      Code:
        ZipFile: |
          import boto3
          import os
          import json

          def lambda_handler(event, context):
              client = boto3.client('route53')
              hosted_zone_name = client.get_hosted_zone(Id=os.environ.get('HOSTED_ZONE_ID')).get('HostedZone').get('Name')

              response = client.change_resource_record_sets(
                  HostedZoneId=os.environ.get('HOSTED_ZONE_ID'),
                  ChangeBatch={
                      'Changes': [
                          {
                              'Action': 'UPSERT',
                              'ResourceRecordSet': {
                                  'Name': f"api.{hosted_zone_name}",
                                  'Type': 'A',
                                  'TTL': 20,
                                  'ResourceRecords': [
                                      {
                                          'Value': event['IpAddress']
                                      }
                                  ]
                              }
                          }
                      ]
                  }
              )
              
              response['ChangeInfo']['SubmittedAt'] = response['ChangeInfo']['SubmittedAt'].isoformat()

              return json.dumps(response)

      Runtime: python3.11

  # DNSRecordLambdaDelete: # delete the record created with Lambda in the private hosted zone upon stack DELETE
  #   Type: AWS::Lambda::Function
  #   Properties:
  #     Handler: index.lambda_handler
  #     Role: !GetAtt DNSRecordLambdaExecutionRole.Arn
  #     Environment:
  #       Variables:
  #         HOSTED_ZONE_ID: !Ref RedisPrivateHostedZone
  #     Code:
  #       ZipFile: |
  #         import boto3
  #         import os
  #         import json

  #         def lambda_handler(event, context):

  #             response = { 'ChangeInfo': { 'Comment': 'Not a DELETE stack event' } }
  #             if event['RequestType'] == 'Delete':

  #                 client = boto3.client('route53')
  #                 hosted_zone_name = client.get_hosted_zone(Id=os.environ.get('HOSTED_ZONE_ID')).get('HostedZone').get('Name')
  #                 record_name = f"api.{hosted_zone_name}"

  #                 # retrieve the current record value necessary for deletion
  #                 response_record_sets = client.list_resource_record_sets(
  #                     HostedZoneId=os.environ.get('HOSTED_ZONE_ID'),
  #                     StartRecordName=record_name,
  #                     StartRecordType='A',
  #                     MaxItems='1'
  #                 )

  #                 current_value = None
  #                 if 'ResourceRecordSets' in response_record_sets:
  #                     record_set = response_record_sets['ResourceRecordSets'][0]
  #                     if record_set['Name'] == record_name and record_set['Type'] == 'A':
  #                         current_value = record_set['ResourceRecords'][0]['Value']

  #                 # if a value has been found for the record
  #                 if current_value:
  #                   response = client.change_resource_record_sets(
  #                       HostedZoneId=os.environ.get('HOSTED_ZONE_ID'),
  #                       ChangeBatch={
  #                           'Changes': [
  #                               {
  #                                   'Action': 'DELETE',
  #                                   'ResourceRecordSet': {
  #                                       'Name': record_name,
  #                                       'Type': 'A',
  #                                       'TTL': 20,
  #                                       'ResourceRecords': [
  #                                           {
  #                                               'Value': current_value
  #                                           }
  #                                       ]
  #                                   }
  #                               }
  #                           ]
  #                       }
  #                   )

  #                   response['ChangeInfo']['SubmittedAt'] = response['ChangeInfo']['SubmittedAt'].isoformat()

  #             return json.dumps(response)

  #     Runtime: python3.11

  # OnStackDeletionCleanUp: # call the Lambda to delete the record in the private hosted zone to avoid failure of stack deletion
  #   Type: Custom::CleanUpPrivateZoneRecordLambda
  #   Properties:
  #     ServiceToken: !GetAtt DNSRecordLambdaDelete.Arn

  # ECSTaskExecutionRole:
  #   Type: AWS::IAM::Role
  #   Properties:
  #     AssumeRolePolicyDocument:
  #       Version: 2012-10-17
  #       Statement:
  #         - Effect: Allow
  #           Principal:
  #             Service: ecs-tasks.amazonaws.com
  #           Action: sts:AssumeRole
  #     ManagedPolicyArns:
  #       - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

  # ECSCloudWatchLogsGroup:
  #   Type: AWS::Logs::LogGroup
  #   Properties:
  #     LogGroupName: !Sub ${AWS::StackName}-ECSRedisTaskGroup

  # ECSTaskDefinition:
  #   Type: AWS::ECS::TaskDefinition
  #   Properties:
  #     Family: !Sub ${AWS::StackName}-ECSRedisTask
  #     ContainerDefinitions:
  #       - Name: redis
  #         Image: redis:7.2.3
  #         Cpu: 0
  #         MemoryReservation: 410
  #         PortMappings:
  #           - Name: redis-80-tcp
  #             ContainerPort: 80
  #             HostPort: 0
  #             Protocol: tcp
  #             AppProtocol: http
  #           - Name: redis-6379-tcp
  #             ContainerPort: 6379
  #             HostPort: 6379
  #             Protocol: tcp
  #         Essential: true
  #         Environment: []
  #         EnvironmentFiles: []
  #         MountPoints: []
  #         VolumesFrom: []
  #         Ulimits: []
  #         LogConfiguration:
  #           LogDriver: awslogs
  #           Options:
  #             awslogs-create-group: true
  #             awslogs-group: !Ref ECSCloudWatchLogsGroup
  #             awslogs-region: !Ref AWS::Region
  #             awslogs-stream-prefix: ecs
  #           SecretOptions: []
  #         HealthCheck:
  #           Command:
  #             - "CMD-SHELL"
  #             - "redis-cli --raw incr ping"
  #           Interval: 5
  #           Timeout: 5
  #           Retries: 3
  #           StartPeriod: 15
  #     ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
  #     RequiresCompatibilities:
  #       - EC2
  #     RuntimePlatform:
  #       CpuArchitecture: ARM64
  #       OperatingSystemFamily: LINUX

  # ECSService:
  #   Type: AWS::ECS::Service
  #   # wait for the EC2 instances to be provisioned to avoid health failures at the start
  #   DependsOn: ECSAutoScalingGroup
  #   Properties:
  #     Cluster: !Ref ECSCluster
  #     DeploymentConfiguration:
  #       MaximumPercent: 100
  #       MinimumHealthyPercent: 0
  #       DeploymentCircuitBreaker:
  #         Enable: true
  #         Rollback: true
  #     DeploymentController:
  #       Type: ECS
  #     DesiredCount: 1
  #     EnableECSManagedTags: true
  #     PlacementConstraints: []
  #     PlacementStrategies:
  #       - Field: attribute:ecs.availability-zone
  #         Type: spread
  #       - Field: instanceId
  #         Type: spread
  #     SchedulingStrategy: REPLICA
  #     ServiceName: !Sub ${AWS::StackName}-ECSService
  #     ServiceConnectConfiguration:
  #       Enabled: false
  #     Tags: []
  #     TaskDefinition: !Ref ECSTaskDefinition

Outputs:
  RedisInstanceDnsRecord:
    Description: Returned value for the created redis dns record.
    Value: !Ref RedisInstanceDnsRecord
  # ECSCluster:
  #   Description: The created cluster.
  #   Value: !Ref ECSCluster
  # RedisInstanceDnsRecord:
  #   Description: DNS name for Redis instance
  #   Value: !Ref RedisInstanceDnsRecord
